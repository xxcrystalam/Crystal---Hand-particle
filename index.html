<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Particle Hands</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for in-browser JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- CRITICAL FIX: Polyfill 'process' to prevent runtime crash in browser -->
    <script>
      window.process = { env: { NODE_ENV: 'production' } };
      
      // Error Catcher: Displays errors on screen instead of black page
      window.onerror = function(message, source, lineno, colno, error) {
        const errDiv = document.getElementById('error-display') || document.createElement('div');
        errDiv.id = 'error-display';
        errDiv.style.cssText = 'position:fixed; top:0; left:0; width:100%; background:rgba(200,0,0,0.9); color:white; padding:20px; z-index:9999; font-family:monospace;';
        errDiv.innerHTML += `<div><strong>Error:</strong> ${message} <br/><small>${source}:${lineno}</small></div>`;
        document.body.appendChild(errDiv);
        console.error(error);
      };
    </script>

    <style>
      body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; }
      #root { width: 100%; height: 100%; }
      ::-webkit-scrollbar { width: 6px; }
      ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
      ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 3px; }
    </style>

    <!-- Import Map using public CDNs -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@google/genai": "https://esm.sh/@google/genai@0.1.1",
    "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.9",
    "lucide-react": "https://esm.sh/lucide-react@0.309.0",
    "react/": "https://aistudiocdn.com/react@^19.2.1/"
  }
}
</script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="typescript, react">
      import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
      import ReactDOM from 'react-dom/client';
      import { Canvas, useFrame } from '@react-three/fiber';
      import { OrbitControls } from '@react-three/drei';
      import * as THREE from 'three';
      import { GoogleGenAI, Type } from "@google/genai";
      import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
      import { Sliders, Maximize, Palette, Sparkles, Hand, Loader2, Star, Heart, Activity, Box, Circle, Disc, Zap, CloudFog } from 'lucide-react';

      // --- CONFIGURATION ---
      // IMPORTANT: Replace the string below with your actual API Key.
      // process.env.API_KEY is polyfilled above to avoid crashes, but you should paste the key here directly for the HTML version.
      const API_KEY = "YOUR_API_KEY_HERE"; 

      // --- TYPES & ENUMS ---
      const ShapeType = {
        SPHERE: 'Sphere',
        CUBE: 'Cube',
        TORUS: 'Torus',
        DNA: 'DNA Helix',
        STAR: 'Star',
        GALAXY: 'Galaxy',
        NEBULA: 'Nebula',
        HEART: 'Heart',
        FIREWORKS: 'Fireworks',
        AI_GENERATED: 'AI Custom',
      };

      const COLORS = [
        '#00ffff', '#ff00ff', '#ffff00', '#ff4400', 
        '#ffffff', '#00ff00', '#7000ff', '#ff0066'
      ];

      // --- SERVICES ---
      let aiInstance = null;
      const getAiClient = () => {
        if (!aiInstance && API_KEY && API_KEY !== "YOUR_API_KEY_HERE") {
          aiInstance = new GoogleGenAI({ apiKey: API_KEY });
        }
        return aiInstance;
      };

      const generateParticleShape = async (description, count) => {
        try {
          const ai = getAiClient();
          if (!ai) throw new Error("API Key missing or invalid. Please edit index.html to add your API Key.");

          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: `Generate a highly aesthetic 3D point cloud shape representing: "${description}". 
            Return a JSON object containing an array of ${count} points. 
            Each point must be an array of 3 numbers [x, y, z]. 
            Normalize all coordinates to be between -3.0 and 3.0.
            Important:
            1. Distribute points evenly to create a solid sense of volume.
            2. Ensure key features are recognizable.`,
            config: {
              responseMimeType: "application/json",
              responseSchema: {
                type: Type.OBJECT,
                properties: {
                  points: {
                    type: Type.ARRAY,
                    items: {
                      type: Type.ARRAY,
                      items: { type: Type.NUMBER },
                    },
                  },
                },
                required: ["points"],
              },
            },
          });

          const jsonText = response.text;
          const data = JSON.parse(jsonText);
          if (Array.isArray(data.points)) return data.points;
          throw new Error("Invalid format");
        } catch (error) {
          console.error("Gemini Error:", error);
          alert("AI Generation failed: " + error.message);
          // Fallback
          return Array.from({ length: count }, () => [
            (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4
          ]);
        }
      };

      // --- COMPONENTS ---

      // 1. Hand Tracker
      const HAND_CONNECTIONS = [
        [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
        [0, 5], [5, 6], [6, 7], [7, 8], // Index
        [0, 9], [9, 10], [10, 11], [11, 12], // Middle
        [0, 13], [13, 14], [14, 15], [15, 16], // Ring
        [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
        [5, 9], [9, 13], [13, 17], [0, 5], [0, 17] // Palm
      ];

      const HandTracker = ({ onHandUpdate, debugMode = false }) => {
        const videoRef = useRef(null);
        const canvasRef = useRef(null);
        const [isReady, setIsReady] = useState(false);
        const [error, setError] = useState(null);
        const [detectedGesture, setDetectedGesture] = useState('None');

        useEffect(() => {
          let handLandmarker = null;
          let animationFrameId;

          const setupMediaPipe = async () => {
            try {
              const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
              );
              handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                  modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                  delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
              });
              startWebcam();
            } catch (err) {
              console.error("MediaPipe error:", err);
              setError("Failed to load tracking.");
            }
          };

          const startWebcam = async () => {
            if (navigator.mediaDevices?.getUserMedia) {
              try {
                const stream = await navigator.mediaDevices.getUserMedia({
                  video: { width: 320, height: 240, facingMode: "user" }
                });
                if (videoRef.current) {
                  videoRef.current.srcObject = stream;
                  videoRef.current.addEventListener("loadeddata", predictWebcam);
                  setIsReady(true);
                }
              } catch (err) {
                setError("Camera permission denied. (Check if site is HTTPS or localhost)");
              }
            } else {
               setError("Camera not supported on this browser/connection.");
            }
          };

          const drawLandmarks = (ctx, landmarks) => {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#00ffff';
            ctx.beginPath();
            for (const [start, end] of HAND_CONNECTIONS) {
              const p1 = landmarks[start];
              const p2 = landmarks[end];
              ctx.moveTo(p1.x * width, p1.y * height);
              ctx.lineTo(p2.x * width, p2.y * height);
            }
            ctx.stroke();
            ctx.fillStyle = '#ff00ff';
            for (const p of landmarks) {
              ctx.beginPath();
              ctx.arc(p.x * width, p.y * height, 3, 0, 2 * Math.PI);
              ctx.fill();
            }
          };

          const predictWebcam = () => {
            if (!videoRef.current || !handLandmarker) return;
            const startTimeMs = performance.now();
            
            if (videoRef.current.videoWidth > 0) {
              // Draw Overlay
              if (canvasRef.current) {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                if (canvas.width !== video.videoWidth) {
                  canvas.width = video.videoWidth;
                  canvas.height = video.videoHeight;
                }
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
              }

              const results = handLandmarker.detectForVideo(videoRef.current, startTimeMs);

              if (results.landmarks && results.landmarks.length > 0) {
                const landmarks = results.landmarks[0];
                
                if (canvasRef.current) {
                   drawLandmarks(canvasRef.current.getContext('2d'), landmarks);
                }

                // 1. Openness
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20];
                let totalDist = 0;
                tips.forEach(idx => {
                  const tip = landmarks[idx];
                  totalDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2) + Math.pow(tip.z - wrist.z, 2));
                });
                let factor = (totalDist / 5 - 0.15) / (0.45 - 0.15);
                factor = Math.max(0, Math.min(1, factor));

                // 2. Position
                const centerPoint = landmarks[9];
                const handX = (0.5 - centerPoint.x) * 3.0; 
                const handY = (0.5 - centerPoint.y) * 3.0; 

                // 3. Gesture
                let gesture = 'None';
                const isFingerOpen = (tipIdx, pipIdx) => {
                  return Math.hypot(landmarks[tipIdx].x - wrist.x, landmarks[tipIdx].y - wrist.y) > 
                         Math.hypot(landmarks[pipIdx].x - wrist.x, landmarks[pipIdx].y - wrist.y);
                };
                const index = isFingerOpen(8, 6);
                const middle = isFingerOpen(12, 10);
                const ring = isFingerOpen(16, 14);
                const pinky = isFingerOpen(20, 18);

                if (index && middle && !ring && !pinky) gesture = 'Victory';
                else if (!index && !middle && !ring && !pinky) gesture = 'Closed_Fist';
                else if (index && middle && ring && pinky) gesture = 'Open_Palm';

                setDetectedGesture(gesture);
                onHandUpdate({ factor, x: handX, y: handY, isTracking: true, gesture });
              } else {
                onHandUpdate({ factor: 0.8, x: 0, y: 0, isTracking: false, gesture: 'None' });
                setDetectedGesture('None');
              }
            }
            animationFrameId = requestAnimationFrame(predictWebcam);
          };

          setupMediaPipe();
          return () => {
            cancelAnimationFrame(animationFrameId);
            if (handLandmarker) handLandmarker.close();
          };
        }, [onHandUpdate]);

        return (
          <div className={`fixed bottom-4 right-4 z-50 transition-opacity duration-500 ${isReady ? 'opacity-100' : 'opacity-0'}`}>
             <div className="relative overflow-hidden rounded-lg border border-gray-700 bg-black/50 backdrop-blur-md">
               {error && <div className="p-2 text-xs text-red-500 max-w-[200px]">{error}</div>}
               <video ref={videoRef} autoPlay playsInline muted className={`h-32 w-40 object-cover transform -scale-x-100 ${debugMode ? 'block' : 'opacity-60 hover:opacity-100'}`} />
               <canvas ref={canvasRef} className={`absolute top-0 left-0 w-full h-full object-cover transform -scale-x-100 pointer-events-none ${debugMode ? 'opacity-100' : 'opacity-60 hover:opacity-100'}`} />
               <div className="absolute top-2 left-2 right-2 flex justify-between pointer-events-none">
                  <span className="bg-black/60 px-1.5 py-0.5 rounded text-[10px] text-white font-mono uppercase">Tracking</span>
                  {detectedGesture !== 'None' && <span className="bg-cyan-500/80 px-1.5 py-0.5 rounded text-[10px] text-white font-bold animate-pulse">{detectedGesture}</span>}
               </div>
             </div>
          </div>
        );
      };

      // 2. Scene & Particles
      const getShapeCoordinates = (type, count) => {
        const coords = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
          let x = 0, y = 0, z = 0;
          const i3 = i * 3;
          if (type === ShapeType.SPHERE) {
            const r = 2.5, theta = Math.random() * Math.PI * 2, phi = Math.acos((Math.random() * 2) - 1);
            x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
          } else if (type === ShapeType.CUBE) {
            const s = 3; x = (Math.random()-0.5)*s; y = (Math.random()-0.5)*s; z = (Math.random()-0.5)*s;
          } else if (type === ShapeType.TORUS) {
            const u = Math.random()*Math.PI*2, v = Math.random()*Math.PI*2, R = 2.0, r = 0.8;
            x = (R + r * Math.cos(v)) * Math.cos(u); y = (R + r * Math.cos(v)) * Math.sin(u); z = r * Math.sin(v);
          } else if (type === ShapeType.DNA) {
             const t = (i / count) * Math.PI * 20, radius = 1.2;
             x = Math.cos(t) * radius + (Math.random()-0.5)*0.2; z = Math.sin(t) * radius + (Math.random()-0.5)*0.2; y = (i / count) * 8 - 4;
          } else if (type === ShapeType.STAR) {
            const theta = Math.random()*Math.PI*2, phi = Math.acos((Math.random()*2)-1);
            const r = 1.0 + Math.pow(Math.abs(Math.sin(theta*5)*Math.sin(phi*5)), 0.5) * 2.5;
            x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.sin(phi) * Math.sin(theta); z = r * Math.cos(phi);
          } else if (type === ShapeType.GALAXY) {
            const r = Math.pow(Math.random(), 0.8) * 4.0; 
            const angle = (r * 2.5) + (Math.PI * 2 / 3) * (i % 3);
            x = Math.cos(angle) * r + (Math.random()-0.5)*0.3; z = Math.sin(angle) * r + (Math.random()-0.5)*0.3; y = (Math.random()-0.5) * (1 - r/4) * 1.5;
          } else if (type === ShapeType.NEBULA) {
             const center = [{x:0,y:0,z:0}, {x:2.5,y:1,z:-0.5}, {x:-2,y:-1.5,z:1}][Math.floor(Math.random()*3)];
             const r = Math.random()*2;
             x = center.x + (Math.random()-0.5)*r; y = center.y + (Math.random()-0.5)*r; z = center.z + (Math.random()-0.5)*r;
          } else if (type === ShapeType.HEART) {
             const t = Math.random()*Math.PI*2, zNorm = (Math.random()*2)-1;
             const scaleZ = Math.pow(1 - Math.pow(Math.abs(zNorm), 2), 0.4);
             const hx = 16 * Math.pow(Math.sin(t), 3);
             const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
             x = hx * scaleZ * 0.15; y = hy * scaleZ * 0.15; z = zNorm * 1.5;
          } else if (type === ShapeType.FIREWORKS) {
             const dist = Math.pow(Math.random(), 0.5) * 4.0;
             const th = Math.random()*Math.PI*2, ph = Math.acos((Math.random()*2)-1);
             x = Math.sin(ph)*Math.cos(th)*dist; y = Math.sin(ph)*Math.sin(th)*dist; z = Math.cos(ph)*dist;
          }
          coords[i3] = x; coords[i3+1] = y; coords[i3+2] = z;
        }
        return coords;
      };

      const Particles = ({ config, handDataRef, setLoading }) => {
        const pointsRef = useRef(null);
        const [targetPositions, setTargetPositions] = useState(null);
        
        useEffect(() => {
          const init = async () => {
            if (config.shape === ShapeType.AI_GENERATED && config.aiPrompt) {
              setLoading(true);
              try {
                const pts = await generateParticleShape(config.aiPrompt, config.count);
                const flat = new Float32Array(config.count * 3);
                pts.forEach((p, i) => { if(i<config.count) { flat[i*3]=p[0]; flat[i*3+1]=p[1]; flat[i*3+2]=p[2]; }});
                setTargetPositions(flat);
              } catch(e) { setTargetPositions(getShapeCoordinates(ShapeType.SPHERE, config.count)); }
              finally { setLoading(false); }
            } else {
              setTargetPositions(getShapeCoordinates(config.shape, config.count));
            }
          };
          init();
        }, [config, setLoading]);

        const initialPositions = useMemo(() => {
          const arr = new Float32Array(config.count * 3);
          for(let i=0; i<config.count*3; i++) arr[i] = (Math.random()-0.5)*10;
          return arr;
        }, [config.count]);

        useFrame((state) => {
          if (!pointsRef.current || !targetPositions) return;
          const pos = pointsRef.current.geometry.attributes.position.array;
          const { factor, x: hX, y: hY, isTracking } = handDataRef.current;
          
          if(isTracking) {
             pointsRef.current.rotation.y = THREE.MathUtils.lerp(pointsRef.current.rotation.y, hX * 1.5, 0.05);
             pointsRef.current.rotation.x = THREE.MathUtils.lerp(pointsRef.current.rotation.x, hY * 1.5, 0.05);
          } else {
             pointsRef.current.rotation.y += 0.002;
             pointsRef.current.rotation.x = THREE.MathUtils.lerp(pointsRef.current.rotation.x, 0, 0.05);
          }

          const exp = 0.05 + (factor * 1.5);
          const t = state.clock.getElapsedTime();
          for(let i=0; i<config.count; i++) {
             const i3 = i*3;
             const tx = targetPositions[i3]*exp, ty = targetPositions[i3+1]*exp, tz = targetPositions[i3+2]*exp;
             const noise = 0.02 + factor*0.05;
             pos[i3] += (tx + Math.sin(t*2+i*0.1)*noise - pos[i3]) * 0.1;
             pos[i3+1] += (ty + Math.cos(t*2+i*0.1)*noise - pos[i3+1]) * 0.1;
             pos[i3+2] += (tz + Math.sin(t*2+i*0.1)*noise - pos[i3+2]) * 0.1;
          }
          pointsRef.current.geometry.attributes.position.needsUpdate = true;
        });

        return (
          <points ref={pointsRef}>
            <bufferGeometry><bufferAttribute attach="attributes-position" count={initialPositions.length/3} array={initialPositions} itemSize={3} /></bufferGeometry>
            <pointsMaterial size={config.size} color={config.color} sizeAttenuation={true} blending={THREE.AdditiveBlending} transparent opacity={0.8} depthWrite={false} />
          </points>
        );
      };

      // 3. Main App
      const SHAPE_ICONS = {
        [ShapeType.SPHERE]: <Circle size={16} />, [ShapeType.CUBE]: <Box size={16} />, [ShapeType.TORUS]: <Disc size={16} />,
        [ShapeType.DNA]: <Activity size={16} />, [ShapeType.STAR]: <Star size={16} />, [ShapeType.GALAXY]: <Sparkles size={16} />,
        [ShapeType.NEBULA]: <CloudFog size={16} />, [ShapeType.HEART]: <Heart size={16} />, [ShapeType.FIREWORKS]: <Zap size={16} />
      };

      const App = () => {
        const [config, setConfig] = useState({ count: 6000, color: '#00ffff', size: 0.05, shape: ShapeType.STAR });
        const [aiPrompt, setAiPrompt] = useState('');
        const [loading, setLoading] = useState(false);
        const [showUi, setShowUi] = useState(true);
        const [debug, setDebug] = useState(false);
        const handDataRef = useRef({ factor: 0.6, x: 0, y: 0, isTracking: false, gesture: 'None' });

        const handleHand = useCallback((data) => {
           handDataRef.current = data;
           if(data.gesture === 'Victory') setConfig(p => p.shape !== ShapeType.HEART ? {...p, shape: ShapeType.HEART} : p);
        }, []);

        return (
          <div className="relative w-full h-screen bg-black text-white font-sans overflow-hidden">
             <div className="absolute inset-0">
               <Canvas camera={{ position: [0, 0, 9], fov: 60 }} dpr={[1, 2]}>
                 <color attach="background" args={['#000000']} />
                 <fog attach="fog" args={['#000000', 5, 20]} />
                 <Particles config={config} handDataRef={handDataRef} setLoading={setLoading} />
                 <OrbitControls enableZoom enablePan={false} />
               </Canvas>
             </div>
             
             <HandTracker onHandUpdate={handleHand} debugMode={debug} />

             {loading && <div className="absolute inset-0 flex items-center justify-center bg-black/80 z-50"><Loader2 className="animate-spin text-cyan-400 w-12 h-12" /></div>}
             
             <button onClick={() => setShowUi(!showUi)} className="absolute top-6 right-6 z-40 p-3 bg-white/10 rounded-full hover:bg-white/20"><Sliders size={20} /></button>
             
             <div className={`absolute top-0 left-0 h-full w-96 bg-black/80 backdrop-blur-xl border-r border-white/10 p-8 transition-transform ${showUi ? 'translate-x-0' : '-translate-x-full'} overflow-y-auto z-30`}>
                <h1 className="text-3xl font-bold mb-6">Particle<span className="text-cyan-400">Core</span></h1>
                
                <div className="mb-6 bg-white/5 p-4 rounded-xl border border-white/10">
                   <h3 className="text-sm font-bold text-cyan-300 flex items-center gap-2 mb-2"><Hand size={16}/> Gestures</h3>
                   <p className="text-xs text-gray-400">Move Hand: Rotate • Open/Close: Scale • Victory: Heart Shape</p>
                </div>

                <div className="grid grid-cols-2 gap-3 mb-6">
                   {Object.values(ShapeType).filter(x => x !== ShapeType.AI_GENERATED).map(s => (
                     <button key={s} onClick={() => setConfig(c => ({...c, shape: s}))} 
                       className={`flex items-center gap-2 px-3 py-2 rounded-lg text-xs border ${config.shape===s ? 'bg-cyan-500/20 border-cyan-400 text-cyan-300' : 'bg-white/5 border-transparent'}`}>
                       {SHAPE_ICONS[s]} {s}
                     </button>
                   ))}
                </div>

                <div className="flex flex-wrap gap-2 mb-6">
                  {COLORS.map(c => <button key={c} onClick={()=>setConfig(prev=>({...prev, color:c}))} className={`w-6 h-6 rounded-full ${config.color===c?'ring-2 ring-white':''}`} style={{background:c}}/>)}
                  <input type="color" value={config.color} onChange={e=>setConfig(p=>({...p, color: e.target.value}))} className="w-6 h-6 rounded-full overflow-hidden bg-transparent" />
                </div>

                <form onSubmit={(e) => { e.preventDefault(); if(aiPrompt) setConfig(p=>({...p, shape: ShapeType.AI_GENERATED, aiPrompt})); }} className="space-y-2 border-t border-white/10 pt-4">
                  <label className="text-xs font-bold text-purple-400 flex items-center gap-2"><Sparkles size={12}/> AI GENERATOR</label>
                  <input type="text" value={aiPrompt} onChange={e=>setAiPrompt(e.target.value)} placeholder="Describe a shape..." className="w-full bg-black/30 border border-white/10 rounded-lg px-3 py-2 text-xs" />
                  <button type="submit" disabled={loading} className="w-full py-2 bg-purple-600 rounded-lg text-xs font-bold hover:bg-purple-500 disabled:opacity-50">GENERATE</button>
                </form>

                <div className="mt-8 flex gap-2">
                   <button onClick={() => document.documentElement.requestFullscreen()} className="flex-1 py-2 bg-white/5 rounded-lg text-xs">Fullscreen</button>
                   <button onClick={() => setDebug(!debug)} className="flex-1 py-2 bg-white/5 rounded-lg text-xs">Toggle Camera</button>
                </div>
             </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>